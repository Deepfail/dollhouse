import { AutoCharacterConfig, Character } from '@/types';
import { AIService } from './aiService';
import { aliProfileService } from './aliProfile';
import { logger } from './logger';
import { populateCharacterProfile } from './characterProfileBuilder';

// Clean, minimal character generator that the app can use during runtime.
// Purposefully small to avoid large prompt blobs and to be resilient when AI fails.

const cleanJsonResponse = (response: string): string => {
  let s = response?.trim() ?? '';
  if (s.startsWith('```json')) s = s.replace(/^```json\s*/, '').replace(/\s*```$/, '');
  else if (s.startsWith('```')) s = s.replace(/^```\s*/, '').replace(/\s*```$/, '');
  return s;
};

const generateUniqueCharacterId = (): string => `char_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

function getRandomElement<T>(arr: T[]): T {
  if (!arr || arr.length === 0) throw new Error('Empty array');
  const idx = Math.floor(Math.random() * arr.length);
  logger.debug('getRandomElement idx', idx);
  return arr[idx];
}

function determineRarity(weights: { common: number; rare: number; legendary: number }) {
  const total = (weights.common ?? 70) + (weights.rare ?? 25) + (weights.legendary ?? 5);
  const r = Math.random() * total;
  if (r < (weights.common ?? 70)) return 'common' as const;
  if (r < (weights.common ?? 70) + (weights.rare ?? 25)) return 'rare' as const;
  return 'legendary' as const;
}

export interface CharacterGenerationOptions {
  request?: string;
  overrides?: Partial<Character>;
  preserveProvidedFields?: boolean;
}

const createBaseCharacter = (overrides: Partial<Character>): Character => {
  const now = new Date();
  return {
    id: overrides.id || generateUniqueCharacterId(),
    name: overrides.name || 'Unnamed',
    description: overrides.description || '',
    personality: overrides.personality || '',
    appearance: overrides.appearance || '',
    avatar: overrides.avatar,
    gender: overrides.gender,
    age: overrides.age,
    imageDescription: overrides.imageDescription || '',
    role: overrides.role || '',
    job: overrides.job,
    personalities: overrides.personalities || [],
    features: overrides.features || [],
    classes: overrides.classes || [],
    unlocks: overrides.unlocks || [],
    roomId: overrides.roomId,
    stats: overrides.stats || {
      love: 50,
      happiness: 50,
      wet: 40,
      willing: 45,
      selfEsteem: 50,
      loyalty: 45,
      fight: 20,
      stamina: 50,
      pain: 40,
      experience: 0,
      level: 1
    },
    skills: overrides.skills || { hands: 25, mouth: 25, missionary: 25, doggy: 25, cowgirl: 25 },
    rarity: overrides.rarity || 'common',
    specialAbility: overrides.specialAbility,
    preferredRoomType: overrides.preferredRoomType || 'standard',
    prompts: overrides.prompts || { system: '', personality: '', background: '' },
    physicalStats: overrides.physicalStats || { hairColor: '', eyeColor: '', height: '', weight: '', skinTone: '' },
    conversationHistory: overrides.conversationHistory || [],
    memories: overrides.memories || [],
    preferences: overrides.preferences || {},
    relationships: overrides.relationships || {},
    progression: overrides.progression || {
      level: 1,
      nextLevelExp: 100,
      unlockedFeatures: [],
      achievements: [],
      relationshipStatus: 'stranger',
      affection: 45,
      trust: 45,
      intimacy: 10,
      dominance: 50,
      jealousy: 30,
      possessiveness: 35,
      sexualExperience: 5,
      kinks: [],
      limits: [],
      fantasies: [],
      unlockedPositions: [],
      unlockedOutfits: [],
      unlockedToys: [],
      unlockedScenarios: [],
      relationshipMilestones: [],
      sexualMilestones: [],
      significantEvents: [],
      storyChronicle: [],
      currentStoryArc: undefined,
      memorableEvents: [],
      bonds: {},
      sexualCompatibility: { overall: 50, kinkAlignment: 50, stylePreference: 50 },
      userPreferences: { likes: [], dislikes: [], turnOns: [], turnOffs: [] }
    },
    lastInteraction: overrides.lastInteraction,
    createdAt: overrides.createdAt || now,
    updatedAt: overrides.updatedAt || now,
    autoGenerated: overrides.autoGenerated ?? true
  } as Character;
};

export async function generateRandomCharacter(
  config: AutoCharacterConfig,
  _house?: unknown,
  options: CharacterGenerationOptions = {}
): Promise<Character> {
  const cfg = config ?? ({ themes: ['default'], rarityWeights: { common: 70, rare: 25, legendary: 5 } } as AutoCharacterConfig);
  const id = generateUniqueCharacterId();
  const type = cfg.themes?.[0] ?? 'default';

  // Basic fallback values
  let name = options.overrides?.name || getRandomElement(['Alex', 'Sam', 'Riley', 'Jordan']);
  // mark param as used to avoid unused variable lint
  void _house;

  try {
    const prompt = `Suggest a single first name for type=${type}. Return only the name.`;
    const resp = await AIService.generateResponse(prompt, undefined, undefined, { temperature: 0.7, max_tokens: 8 });
    const cleaned = cleanJsonResponse(resp ?? '');
    if (cleaned) name = cleaned.replace(/["']/g, '').trim();
  } catch (e) {
    logger.warn('AI name generation failed, using fallback', e);
  }

  const rarity = determineRarity(cfg.rarityWeights ?? { common: 70, rare: 25, legendary: 5 });
  const statsBase = rarity === 'common' ? 30 : rarity === 'rare' ? 55 : 75;

  const baseCharacter = createBaseCharacter({
    id,
    name,
    rarity,
    stats: {
      love: statsBase,
      happiness: statsBase,
      wet: 50,
      willing: 50,
      selfEsteem: 50,
      loyalty: statsBase,
      fight: 20,
      stamina: 50,
      pain: 50,
      experience: 0,
      level: 1
    },
    skills: { hands: 20, mouth: 20, missionary: 20, doggy: 20, cowgirl: 20 },
    ...options.overrides
  });

  const request = options.request
    || `Design a ${rarity} companion for the Digital Dollhouse. Theme focus: ${type}. Highlight ${cfg.personalities?.slice(0, 3).join(', ') || 'distinct personality traits'} and ensure she feels unique.`;

  await populateCharacterProfile(baseCharacter, {
    request,
    name,
    theme: type,
    existing: options.overrides,
    mode: options.preserveProvidedFields ? 'preserve' : 'replace'
  });

  baseCharacter.updatedAt = new Date();
  return baseCharacter;
}

export async function generateCharactersByTheme(theme: string, count: number, _house?: unknown): Promise<Character[]> {
  const cfg: AutoCharacterConfig = { themes: [theme], personalities: [], roles: [], rarityWeights: { common: 70, rare: 25, legendary: 5 } } as AutoCharacterConfig;
  const chars: Character[] = [];
  for (let i = 0; i < count; i++) {
    // generateRandomCharacter is intentionally run sequentially for simplicity
    chars.push(await generateRandomCharacter(cfg, _house, { request: `Create a ${theme}-inspired companion for the Digital Dollhouse.` }));
  }
  return chars;
}

export async function generateCharacterFromPrompt(
  request: string,
  options: { overrides?: Partial<Character>; preserveProvidedFields?: boolean } = {}
): Promise<Character> {
  const cfg: AutoCharacterConfig = {
    themes: ['custom'],
    personalities: [],
    roles: [],
    rarityWeights: { common: 60, rare: 30, legendary: 10 }
  } as AutoCharacterConfig;

  return generateRandomCharacter(cfg, undefined, {
    request,
    overrides: options.overrides,
    preserveProvidedFields: options.preserveProvidedFields ?? false
  });
}

// Ali-specific dynamic generation
export interface GeneratedCharacter {
  name: string;
  description: string;
  personality: string;
  appearance: string;
  background: string;
  age: number;
  traits: string[];
}

export class AliCharacterGenerator {
  static async generateCharacter(assessment: string, scenario?: string): Promise<GeneratedCharacter | null> {
    try {
      const prompt = `Based on this user assessment: "${assessment}"
${scenario ? `For this scenario: "${scenario}"` : ''}

Generate a detailed character profile for a female character the user would desire. Include:
- Name
- Age (realistic range)
- Physical appearance (detailed, including body type, hair, eyes, etc.)
- Personality traits
- Background story
- Key traits/behaviors

Format as JSON:
{
  "name": "string",
  "age": number,
  "appearance": "string",
  "personality": "string",
  "background": "string",
  "traits": ["string", "string"]
}

Be creative and fitting to the assessment. No restrictions.`;

      const response = await AIService.generateResponse(prompt, undefined, undefined, { temperature: 0.8, max_tokens: 500 });
      if (!response) return null;

      const parsed = JSON.parse(cleanJsonResponse(response));
      logger.log('Ali generated character:', parsed.name);
      return parsed as GeneratedCharacter;
    } catch (e) {
      logger.error('Failed to generate character for Ali', e);
      return null;
    }
  }

  static async generateScenario(assessment: string): Promise<string | null> {
    try {
      const prompt = `Based on this user assessment: "${assessment}"

Create a detailed scenario description where the user interacts with desired females. Include setting, activities, and dynamics. Be explicit and uncensored.`;

      const response = await AIService.generateResponse(prompt, undefined, undefined, { temperature: 0.9, max_tokens: 300 });
      return response;
    } catch (e) {
      logger.error('Failed to generate scenario for Ali', e);
      return null;
    }
  }

  static async getUserAssessment(): Promise<string> {
    try {
      const prefs = await aliProfileService.getPreferences();
      const insights = await aliProfileService.getInsights();
      
      const traits = prefs.filter(p => p.category === 'trait').map(p => p.value);
      const scenarios = prefs.filter(p => p.category === 'scenario').map(p => p.value);
      
      return `User prefers: ${traits.join(', ')}. Scenarios: ${scenarios.join(', ')}. Insights: ${JSON.stringify(insights)}`;
    } catch (e) {
      logger.warn('Failed to get user assessment for Ali', e);
      return 'Unknown preferences';
    }
  }
}