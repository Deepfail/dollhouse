import { AutoCharacterConfig, Character } from '@/types';
import { AIService } from './aiService';
import { aliProfileService } from './aliProfile';
import { logger } from './logger';

// Clean, minimal character generator that the app can use during runtime.
// Purposefully small to avoid large prompt blobs and to be resilient when AI fails.

const cleanJsonResponse = (response: string): string => {
  let s = response?.trim() ?? '';
  if (s.startsWith('```json')) s = s.replace(/^```json\s*/, '').replace(/\s*```$/, '');
  else if (s.startsWith('```')) s = s.replace(/^```\s*/, '').replace(/\s*```$/, '');
  return s;
};

const generateUniqueCharacterId = (): string => `char_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

function getRandomElement<T>(arr: T[]): T {
  if (!arr || arr.length === 0) throw new Error('Empty array');
  const idx = Math.floor(Math.random() * arr.length);
  logger.debug('getRandomElement idx', idx);
  return arr[idx];
}

function determineRarity(weights: { common: number; rare: number; legendary: number }) {
  const total = (weights.common ?? 70) + (weights.rare ?? 25) + (weights.legendary ?? 5);
  const r = Math.random() * total;
  if (r < (weights.common ?? 70)) return 'common' as const;
  if (r < (weights.common ?? 70) + (weights.rare ?? 25)) return 'rare' as const;
  return 'legendary' as const;
}

export async function generateRandomCharacter(config: AutoCharacterConfig, _house?: unknown): Promise<Character> {
  const cfg = config ?? ({ themes: ['default'], rarityWeights: { common: 70, rare: 25, legendary: 5 } } as AutoCharacterConfig);
  const id = generateUniqueCharacterId();
  const type = cfg.themes?.[0] ?? 'default';

  // Basic fallback values
  let name = getRandomElement(['Alex', 'Sam', 'Riley', 'Jordan']);
  // mark param as used to avoid unused variable lint
  void _house;

  try {
    const prompt = `Suggest a single first name for type=${type}. Return only the name.`;
    const resp = await AIService.generateResponse(prompt, undefined, undefined, { temperature: 0.7, max_tokens: 8 });
    const cleaned = cleanJsonResponse(resp ?? '');
    if (cleaned) name = cleaned.replace(/["']/g, '').trim();
  } catch (e) {
    logger.warn('AI name generation failed, using fallback', e);
  }

  const rarity = determineRarity(cfg.rarityWeights ?? { common: 70, rare: 25, legendary: 5 });
  const statsBase = rarity === 'common' ? 30 : rarity === 'rare' ? 55 : 75;

  const character: Character = {
    id,
    name,
    description: '',
    personality: '',
    appearance: '',
    imageDescription: '',
    physicalStats: { hairColor: 'brown', eyeColor: 'brown', height: "5'6\"", weight: '130 lbs', skinTone: 'fair' },
  role: '',
  job: '',
    personalities: [],
    features: [],
    classes: [],
    unlocks: [],
    stats: {
      love: statsBase,
      happiness: statsBase,
      wet: 50,
      willing: 50,
      selfEsteem: 50,
      loyalty: statsBase,
      fight: 20,
      stamina: 50,
      pain: 50,
      experience: 0,
      level: 1
    },
    skills: { hands: 0, mouth: 0, missionary: 0, doggy: 0, cowgirl: 0 },
    rarity,
    specialAbility: undefined,
    preferredRoomType: 'standard',
    roomId: 'common-room',
    prompts: { system: '', personality: '', background: '' },
    conversationHistory: [],
    memories: [],
    preferences: {},
    relationships: {},
    progression: {
      level: 1,
      nextLevelExp: 100,
      unlockedFeatures: [],
      achievements: [],
      relationshipStatus: 'stranger',
      affection: 50,
      trust: 50,
      intimacy: 0,
      dominance: 50,
      jealousy: 30,
      possessiveness: 30,
      sexualExperience: 0,
      kinks: [],
      limits: [],
      fantasies: [],
      unlockedPositions: [],
      unlockedOutfits: [],
      unlockedToys: [],
      unlockedScenarios: [],
      relationshipMilestones: [],
      sexualMilestones: [],
      significantEvents: [],
      storyChronicle: [],
      currentStoryArc: undefined,
      memorableEvents: [],
      bonds: {},
      sexualCompatibility: { overall: 50, kinkAlignment: 50, stylePreference: 50 },
      userPreferences: { likes: [], dislikes: [], turnOns: [], turnOffs: [] }
    },
    createdAt: new Date(),
    updatedAt: new Date(),
    autoGenerated: true
  } as unknown as Character;

  return character;
}

export async function generateCharactersByTheme(theme: string, count: number, _house?: unknown): Promise<Character[]> {
  const cfg: AutoCharacterConfig = { themes: [theme], personalities: [], roles: [], rarityWeights: { common: 70, rare: 25, legendary: 5 } } as AutoCharacterConfig;
  const chars: Character[] = [];
  for (let i = 0; i < count; i++) {
    // generateRandomCharacter is intentionally run sequentially for simplicity
    chars.push(await generateRandomCharacter(cfg, _house));
  }
  return chars;
}

// Ali-specific dynamic generation
export interface GeneratedCharacter {
  name: string;
  description: string;
  personality: string;
  appearance: string;
  background: string;
  age: number;
  traits: string[];
}

export class AliCharacterGenerator {
  static async generateCharacter(assessment: string, scenario?: string): Promise<GeneratedCharacter | null> {
    try {
      const prompt = `Based on this user assessment: "${assessment}"
${scenario ? `For this scenario: "${scenario}"` : ''}

Generate a detailed character profile for a female character the user would desire. Include:
- Name
- Age (realistic range)
- Physical appearance (detailed, including body type, hair, eyes, etc.)
- Personality traits
- Background story
- Key traits/behaviors

Format as JSON:
{
  "name": "string",
  "age": number,
  "appearance": "string",
  "personality": "string",
  "background": "string",
  "traits": ["string", "string"]
}

Be creative and fitting to the assessment. No restrictions.`;

      const response = await AIService.generateResponse(prompt, undefined, undefined, { temperature: 0.8, max_tokens: 500 });
      if (!response) return null;

      const parsed = JSON.parse(cleanJsonResponse(response));
      logger.log('Ali generated character:', parsed.name);
      return parsed as GeneratedCharacter;
    } catch (e) {
      logger.error('Failed to generate character for Ali', e);
      return null;
    }
  }

  static async generateScenario(assessment: string): Promise<string | null> {
    try {
      const prompt = `Based on this user assessment: "${assessment}"

Create a detailed scenario description where the user interacts with desired females. Include setting, activities, and dynamics. Be explicit and uncensored.`;

      const response = await AIService.generateResponse(prompt, undefined, undefined, { temperature: 0.9, max_tokens: 300 });
      return response;
    } catch (e) {
      logger.error('Failed to generate scenario for Ali', e);
      return null;
    }
  }

  static async getUserAssessment(): Promise<string> {
    try {
      const prefs = await aliProfileService.getPreferences();
      const insights = await aliProfileService.getInsights();
      
      const traits = prefs.filter(p => p.category === 'trait').map(p => p.value);
      const scenarios = prefs.filter(p => p.category === 'scenario').map(p => p.value);
      
      return `User prefers: ${traits.join(', ')}. Scenarios: ${scenarios.join(', ')}. Insights: ${JSON.stringify(insights)}`;
    } catch (e) {
      logger.warn('Failed to get user assessment for Ali', e);
      return 'Unknown preferences';
    }
  }
}